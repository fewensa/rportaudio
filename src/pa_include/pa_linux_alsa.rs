/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    #[doc = " Error codes returned by PortAudio functions."]
    #[doc = "Note that with the exception of paNoError, all PaErrorCodes are negative."]
    pub type PaError = ::std::os::raw::c_int;
    pub const PaHostApiTypeId_paInDevelopment: root::PaHostApiTypeId = 0;
    pub const PaHostApiTypeId_paDirectSound: root::PaHostApiTypeId = 1;
    pub const PaHostApiTypeId_paMME: root::PaHostApiTypeId = 2;
    pub const PaHostApiTypeId_paASIO: root::PaHostApiTypeId = 3;
    pub const PaHostApiTypeId_paSoundManager: root::PaHostApiTypeId = 4;
    pub const PaHostApiTypeId_paCoreAudio: root::PaHostApiTypeId = 5;
    pub const PaHostApiTypeId_paOSS: root::PaHostApiTypeId = 7;
    pub const PaHostApiTypeId_paALSA: root::PaHostApiTypeId = 8;
    pub const PaHostApiTypeId_paAL: root::PaHostApiTypeId = 9;
    pub const PaHostApiTypeId_paBeOS: root::PaHostApiTypeId = 10;
    pub const PaHostApiTypeId_paWDMKS: root::PaHostApiTypeId = 11;
    pub const PaHostApiTypeId_paJACK: root::PaHostApiTypeId = 12;
    pub const PaHostApiTypeId_paWASAPI: root::PaHostApiTypeId = 13;
    pub const PaHostApiTypeId_paAudioScienceHPI: root::PaHostApiTypeId = 14;
    #[doc = " Unchanging unique identifiers for each supported host API. This type"]
    #[doc = "is used in the PaHostApiInfo structure. The values are guaranteed to be"]
    #[doc = "unique and to never change, thus allowing code to be written that"]
    #[doc = "conditionally uses host API specific extensions."]
    #[doc = ""]
    #[doc = "New type ids will be allocated when support for a host API reaches"]
    #[doc = "\"public alpha\" status, prior to that developers should use the"]
    #[doc = "paInDevelopment type id."]
    #[doc = ""]
    #[doc = "@see PaHostApiInfo"]
    pub type PaHostApiTypeId = u32;
    #[doc = "A single PaStream can provide multiple channels of real-time"]
    #[doc = "streaming audio input and output to a client application. A stream"]
    #[doc = "provides access to audio hardware represented by one or more"]
    #[doc = "PaDevices. Depending on the underlying Host API, it may be possible"]
    #[doc = "to open multiple streams using the same device, however this behavior"]
    #[doc = "is implementation defined. Portable applications should assume that"]
    #[doc = "a PaDevice may be simultaneously used by at most one PaStream."]
    #[doc = ""]
    #[doc = "Pointers to PaStream objects are passed between PortAudio functions that"]
    #[doc = "operate on streams."]
    #[doc = ""]
    #[doc = "@see Pa_OpenStream, Pa_OpenDefaultStream, Pa_OpenDefaultStream, Pa_CloseStream,"]
    #[doc = "Pa_StartStream, Pa_StopStream, Pa_AbortStream, Pa_IsStreamActive,"]
    #[doc = "Pa_GetStreamTime, Pa_GetStreamCpuLoad"]
    pub type PaStream = ::std::os::raw::c_void;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct PaAlsaStreamInfo {
        pub size: ::std::os::raw::c_ulong,
        pub hostApiType: root::PaHostApiTypeId,
        pub version: ::std::os::raw::c_ulong,
        pub deviceString: *const ::std::os::raw::c_char,
    }
    extern "C" {
        #[doc = " Initialize host API specific structure, call this before setting relevant attributes."]
        pub fn PaAlsa_InitializeStreamInfo(info: *mut root::PaAlsaStreamInfo);
    }
    extern "C" {
        #[doc = " Instruct whether to enable real-time priority when starting the audio thread."]
        #[doc = ""]
        #[doc = " If this is turned on by the stream is started, the audio callback thread will be created"]
        #[doc = " with the FIFO scheduling policy, which is suitable for realtime operation."]
        pub fn PaAlsa_EnableRealtimeScheduling(
            s: *mut root::PaStream,
            enable: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Get the ALSA-lib card index of this stream's input device."]
        pub fn PaAlsa_GetStreamInputCard(
            s: *mut root::PaStream,
            card: *mut ::std::os::raw::c_int,
        ) -> root::PaError;
    }
    extern "C" {
        #[doc = " Get the ALSA-lib card index of this stream's output device."]
        pub fn PaAlsa_GetStreamOutputCard(
            s: *mut root::PaStream,
            card: *mut ::std::os::raw::c_int,
        ) -> root::PaError;
    }
    extern "C" {
        #[doc = " Set the number of periods (buffer fragments) to configure devices with."]
        #[doc = ""]
        #[doc = " By default the number of periods is 4, this is the lowest number of periods that works well on"]
        #[doc = " the author's soundcard."]
        #[doc = " @param numPeriods The number of periods."]
        pub fn PaAlsa_SetNumPeriods(numPeriods: ::std::os::raw::c_int) -> root::PaError;
    }
    extern "C" {
        #[doc = " Set the maximum number of times to retry opening busy device (sleeping for a"]
        #[doc = " short interval inbetween)."]
        pub fn PaAlsa_SetRetriesBusy(retries: ::std::os::raw::c_int) -> root::PaError;
    }
    extern "C" {
        #[doc = " Set the path and name of ALSA library file if PortAudio is configured to load it dynamically (see"]
        #[doc = "  PA_ALSA_DYNAMIC). This setting will overwrite the default name set by PA_ALSA_PATHNAME define."]
        #[doc = " @param pathName Full path with filename. Only filename can be used, but dlopen() will lookup default"]
        #[doc = "                 searchable directories (/usr/lib;/usr/local/lib) then."]
        pub fn PaAlsa_SetLibraryPathName(pathName: *const ::std::os::raw::c_char);
    }
}
