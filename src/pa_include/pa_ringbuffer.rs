/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub type ring_buffer_size_t = ::std::os::raw::c_long;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct PaUtilRingBuffer {
        #[doc = "< Number of elements in FIFO. Power of 2. Set by PaUtil_InitRingBuffer."]
        pub bufferSize: root::ring_buffer_size_t,
        #[doc = "< Index of next writable element. Set by PaUtil_AdvanceRingBufferWriteIndex."]
        pub writeIndex: root::ring_buffer_size_t,
        #[doc = "< Index of next readable element. Set by PaUtil_AdvanceRingBufferReadIndex."]
        pub readIndex: root::ring_buffer_size_t,
        #[doc = "< Used for wrapping indices with extra bit to distinguish full/empty."]
        pub bigMask: root::ring_buffer_size_t,
        #[doc = "< Used for fitting indices to buffer."]
        pub smallMask: root::ring_buffer_size_t,
        #[doc = "< Number of bytes per element."]
        pub elementSizeBytes: root::ring_buffer_size_t,
        #[doc = "< Pointer to the buffer containing the actual data."]
        pub buffer: *mut ::std::os::raw::c_char,
    }
    extern "C" {
        #[doc = " Initialize Ring Buffer to empty state ready to have elements written to it."]
        #[doc = ""]
        #[doc = "@param rbuf The ring buffer."]
        #[doc = ""]
        #[doc = "@param elementSizeBytes The size of a single data element in bytes."]
        #[doc = ""]
        #[doc = "@param elementCount The number of elements in the buffer (must be a power of 2)."]
        #[doc = ""]
        #[doc = "@param dataPtr A pointer to a previously allocated area where the data"]
        #[doc = "will be maintained.  It must be elementCount*elementSizeBytes long."]
        #[doc = ""]
        #[doc = "@return -1 if elementCount is not a power of 2, otherwise 0."]
        pub fn PaUtil_InitializeRingBuffer(
            rbuf: *mut root::PaUtilRingBuffer,
            elementSizeBytes: root::ring_buffer_size_t,
            elementCount: root::ring_buffer_size_t,
            dataPtr: *mut ::std::os::raw::c_void,
        ) -> root::ring_buffer_size_t;
    }
    extern "C" {
        #[doc = " Reset buffer to empty. Should only be called when buffer is NOT being read or written."]
        #[doc = ""]
        #[doc = "@param rbuf The ring buffer."]
        pub fn PaUtil_FlushRingBuffer(rbuf: *mut root::PaUtilRingBuffer);
    }
    extern "C" {
        #[doc = " Retrieve the number of elements available in the ring buffer for writing."]
        #[doc = ""]
        #[doc = "@param rbuf The ring buffer."]
        #[doc = ""]
        #[doc = "@return The number of elements available for writing."]
        pub fn PaUtil_GetRingBufferWriteAvailable(
            rbuf: *const root::PaUtilRingBuffer,
        ) -> root::ring_buffer_size_t;
    }
    extern "C" {
        #[doc = " Retrieve the number of elements available in the ring buffer for reading."]
        #[doc = ""]
        #[doc = "@param rbuf The ring buffer."]
        #[doc = ""]
        #[doc = "@return The number of elements available for reading."]
        pub fn PaUtil_GetRingBufferReadAvailable(
            rbuf: *const root::PaUtilRingBuffer,
        ) -> root::ring_buffer_size_t;
    }
    extern "C" {
        #[doc = " Write data to the ring buffer."]
        #[doc = ""]
        #[doc = "@param rbuf The ring buffer."]
        #[doc = ""]
        #[doc = "@param data The address of new data to write to the buffer."]
        #[doc = ""]
        #[doc = "@param elementCount The number of elements to be written."]
        #[doc = ""]
        #[doc = "@return The number of elements written."]
        pub fn PaUtil_WriteRingBuffer(
            rbuf: *mut root::PaUtilRingBuffer,
            data: *const ::std::os::raw::c_void,
            elementCount: root::ring_buffer_size_t,
        ) -> root::ring_buffer_size_t;
    }
    extern "C" {
        #[doc = " Read data from the ring buffer."]
        #[doc = ""]
        #[doc = "@param rbuf The ring buffer."]
        #[doc = ""]
        #[doc = "@param data The address where the data should be stored."]
        #[doc = ""]
        #[doc = "@param elementCount The number of elements to be read."]
        #[doc = ""]
        #[doc = "@return The number of elements read."]
        pub fn PaUtil_ReadRingBuffer(
            rbuf: *mut root::PaUtilRingBuffer,
            data: *mut ::std::os::raw::c_void,
            elementCount: root::ring_buffer_size_t,
        ) -> root::ring_buffer_size_t;
    }
    extern "C" {
        #[doc = " Get address of region(s) to which we can write data."]
        #[doc = ""]
        #[doc = "@param rbuf The ring buffer."]
        #[doc = ""]
        #[doc = "@param elementCount The number of elements desired."]
        #[doc = ""]
        #[doc = "@param dataPtr1 The address where the first (or only) region pointer will be"]
        #[doc = "stored."]
        #[doc = ""]
        #[doc = "@param sizePtr1 The address where the first (or only) region length will be"]
        #[doc = "stored."]
        #[doc = ""]
        #[doc = "@param dataPtr2 The address where the second region pointer will be stored if"]
        #[doc = "the first region is too small to satisfy elementCount."]
        #[doc = ""]
        #[doc = "@param sizePtr2 The address where the second region length will be stored if"]
        #[doc = "the first region is too small to satisfy elementCount."]
        #[doc = ""]
        #[doc = "@return The room available to be written or elementCount, whichever is smaller."]
        pub fn PaUtil_GetRingBufferWriteRegions(
            rbuf: *mut root::PaUtilRingBuffer,
            elementCount: root::ring_buffer_size_t,
            dataPtr1: *mut *mut ::std::os::raw::c_void,
            sizePtr1: *mut root::ring_buffer_size_t,
            dataPtr2: *mut *mut ::std::os::raw::c_void,
            sizePtr2: *mut root::ring_buffer_size_t,
        ) -> root::ring_buffer_size_t;
    }
    extern "C" {
        #[doc = " Advance the write index to the next location to be written."]
        #[doc = ""]
        #[doc = "@param rbuf The ring buffer."]
        #[doc = ""]
        #[doc = "@param elementCount The number of elements to advance."]
        #[doc = ""]
        #[doc = "@return The new position."]
        pub fn PaUtil_AdvanceRingBufferWriteIndex(
            rbuf: *mut root::PaUtilRingBuffer,
            elementCount: root::ring_buffer_size_t,
        ) -> root::ring_buffer_size_t;
    }
    extern "C" {
        #[doc = " Get address of region(s) from which we can read data."]
        #[doc = ""]
        #[doc = "@param rbuf The ring buffer."]
        #[doc = ""]
        #[doc = "@param elementCount The number of elements desired."]
        #[doc = ""]
        #[doc = "@param dataPtr1 The address where the first (or only) region pointer will be"]
        #[doc = "stored."]
        #[doc = ""]
        #[doc = "@param sizePtr1 The address where the first (or only) region length will be"]
        #[doc = "stored."]
        #[doc = ""]
        #[doc = "@param dataPtr2 The address where the second region pointer will be stored if"]
        #[doc = "the first region is too small to satisfy elementCount."]
        #[doc = ""]
        #[doc = "@param sizePtr2 The address where the second region length will be stored if"]
        #[doc = "the first region is too small to satisfy elementCount."]
        #[doc = ""]
        #[doc = "@return The number of elements available for reading."]
        pub fn PaUtil_GetRingBufferReadRegions(
            rbuf: *mut root::PaUtilRingBuffer,
            elementCount: root::ring_buffer_size_t,
            dataPtr1: *mut *mut ::std::os::raw::c_void,
            sizePtr1: *mut root::ring_buffer_size_t,
            dataPtr2: *mut *mut ::std::os::raw::c_void,
            sizePtr2: *mut root::ring_buffer_size_t,
        ) -> root::ring_buffer_size_t;
    }
    extern "C" {
        #[doc = " Advance the read index to the next location to be read."]
        #[doc = ""]
        #[doc = "@param rbuf The ring buffer."]
        #[doc = ""]
        #[doc = "@param elementCount The number of elements to advance."]
        #[doc = ""]
        #[doc = "@return The new position."]
        pub fn PaUtil_AdvanceRingBufferReadIndex(
            rbuf: *mut root::PaUtilRingBuffer,
            elementCount: root::ring_buffer_size_t,
        ) -> root::ring_buffer_size_t;
    }
}
